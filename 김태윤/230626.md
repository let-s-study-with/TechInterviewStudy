### 1. 객체지향 프로그래밍이란?
- 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.
- 장점
  - 코드 재사용 용이
  - 유지보수가 쉽다
  - 대형 프로젝트에 적합
- 단점
  - 처리 속도가 상대적으로 느림
  - 객체가 많으면 용량이 커짐
  - 설계시 많은 시간이 필요

### 2. 어떤 특징이 있는가?
- 캡슐화
  - 기능과 특성의 모음을 "클래스"라는 "켑슐"에 분류해서 넣는 것
  - 1. 코드를 재수정 없이 재활용 가능
  - 2. 접근 제어자를 통한 정보 은닉
- 상속
  - 객체가 다른 객체를 상속받아 상속받은 객체의 요소를 사용하는 것
- 추상화
  - 공통의 속성이나 기능을 묶어 이름을 붙이는 것
- 다형성
  - 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것 
  - 오버라이딩: 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것.
  - 오버로딩: 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.

### 3. Doker란?
- Go 언어로 작성된 리눅스 컨테이너 기반으로 하는 오픈소스 가상화 플랫폼이다.
이를 통해 개발자는 애플리케이션과 그에 필요한 런타임, 라이브러리 등을 컨테이너로 묶어서 어떤 환경에서도 일관되게 실행할 수 있으며,
시스템 관리자는 호스트 시스템과는 독립적으로 여러 개의 컨테이너를 실행하고 관리할 수 있다.

### 4. 그럼 컨테이너 가상화는 뭐고 왜 하는 건가요?
- 애플리케이션과 그에 필요한 설정 등을 격리된 환경인 컨테이너에 패키징하는 기술이다.
이 컨테이너는 호스트 시스템과는 독립적으로 실행되며 필요한 모든 요소를 포함하고 있어 애플리케이션을 어떤 환경에서도 일관되게 실행할 수 있게 해준다.
- 이점
  - 1. 환경 격리
    2. 빠른 배포
    3. 확장성
    4. 일관성

### 5. JDK와 JRE는 뭘까?
- JDK(Java Development Kit)
  - 개발자들이 자바로 개발하는 데 사용
- JRE(Java Runtime Environment)
  - 자바로 만들어진 프로그램을 실행시키는데 필요한 라이브러리들과 API, JVM이 포함되어 있다.
- Java로 프로그램을 직접 개발하려면 JDK가 필요하고 Java로 만들어진 프로그램을 실행시키려면 JRE가 필요

### 6. Dependency Injection(DI) 의존성을 주입하는 방법
- 필드 주입(@Authwired, @Inject 등)
- 메서드 주입(@Setter)
- 생성자 주입

### 7. 본인이 사용하는 개발 도구와 환경
- 언어: Java
- IDE: 인텔리제이
- 버전 관리: Git, GitHub
- 데이터베이스: mairaDB
- 빌드 도구: Gradle
- 서버 환경: AWS

### 8. 프로세스와 스레드
- 프로세스: 자신만의 고유 공간과 자원을 할당받아 사용
- 스레드: 다른 스레드와 공간과 자원을 공유하면서 사용
- 프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위

### 9. Garbage Collector
- 힙 영역에서 동적으로 할당된 메모리를 관리하고, 사용되지 않는 객체들을 주기적으로 탐지하여 삭제하는 역할을 수행한다.
- 개발자가 직접 메모리할당과 해제를 처리하는 번거로움을 덜어주고 이를 통해 메모리 누수를 방지할 수 있다.

### 10. 변수의 참조 타입과 원시 타입
- 원시 타입: 정수, 실수, 문자, 논리 리터럴등의 실제 데이터 값을 저장하는 타입
- 참조 타입: 객체(Object)의 번지를 참조하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입

### 11. 백터와 ArrayList
- 둘 다 배열(Array)를 기반으로 한 컬렉션이다. 다른점은 메서드에 동기화 키워드 유무이다.
- ArrayList는 동기화가 되어있지 않다. 다수의 쓰레드가 동시에 접근할 경우 문제가 터질 수 있다.
즉, ArrayList는 멀티 쓰레드 환경에서 안전하지 않다.
- Vector는 동기화 되어 있다.

### 12. TCP와 UDP
- TCP: 인터넷 상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
  - 연결 지향 프로토콜 
  - 3-wat handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
  - 높은 신뢰성 보장
  - UDP보다 느리다.
- UDP: 데이터를 데이터그램 단위로 처리하는 프로토콜
  - 비연결형 서비스로 데이터그램 방식을 제공
  - 신뢰성이 낮다
  - TCP보다 속도가 빠르다.

 ### 13. 싱클톤 패턴이란?
 - 객체의 인스턴스가 오직 1개만 생성되는 패턴을 의미
 - 장점
   - 1. 메모리 낭비 방지
     2. 이미 생성된 인스턴스를 활용하기 때문에 속도가 빠름
     3. 데이터 공유가 쉽다.
- 단점
  - 1. 정적 팩토리 메서드에서 객체 생성을 확인하고 생성자를 호출하는 경우에 멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 위해 syncronized 키워드를 사용해야 한다.
    2. 테스트 하기 어렵다.
    3. 의존 관계상 클라이언트가 구체 클래스에 의존하고 있는데 이는 SOLID 원칙 중 DIP를 위반한다.

### 14. 캐시 와 쿠키
| 항목 | 캐시(Cache) | 쿠키(Cookie) |
|-----|------------|-------------|
| 정의 | 웹 페이지 요소를 저장하기 위한 임시 저장소이다. 특히, 후에 필요할 것 같은 요소들을 저장한다. 이러한 요소들은 그림 파일이나 문서 파일 등이 될 수 있다. | 정보를 저장하기 위해 사용된다. 기본적으로 웹 서버에서 PC로 보내는 작은 파일들을 저장한다. 보통 쿠키는 누군가 특정한 웹 사이트를 접속할 때 발생한다. |
| 목적 | 웹 페이지가 빠르게 렌더링 할 수 있도록 도와준다. | 사용자의 인증을 도와준다. |
| 삭제 | 사용자가 직접 수동으로 삭제해주어야 한다. 만료 기간이 있어 시간이 지나면 자동 삭제 된다. | 사용자가 직접 수동으로 삭제해주어야 한다. 만료 기간이 있어 시간이 지나면 자동 삭제 된다. |
| 예시 | 오디오, 비디오 파일 등이 있다. | 유저의 선호도 (로그인 정보, 방문 기록, 방문 횟수) |


### 15. HTTP 와 HTTPS
- HTTP: 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜
  - 암호화가 추가되지 않았기 때문에 보안에 취약 
- HTTPS: HTTP에 데이터 암호화가 추가된 프로토콜
  - 안전하게 데이터를 주고 받을 수 있다. 하지만 암호화/복호화 과정이 필요하기 때문에 속도가 비교적 느리다.
 
### 16. HTTPS 암호화 방식
- 대칭키 암호화
  - 동일한 키로 암호화, 복호화가 가능
  - 공개키보다 빠르게 통신할 수 있다. 
  - HTTPS에서는 대칭키 암호화 방식인 AES를 주로 사용한다.
- 공개키 방식
  - A키로 암호화를 하면 B키로 복호화를 할 수 있다.
  - B키로 암호화를 하면 A키로 복호화를 할 수 있다.
  - 둘 중 하나를 개인키라 부르며 자신만 가지고 있어 공개되지 않는다.
  - 나머지 하나를 공개키라 부르며 타인에게 제공한다. 공개키는 유출 되어도 개인키를 모르면 복호화 할 수 없기 때문에 안전하다.    

### 17. 접근제어자
1. public: 모든 클래스에서 접근 가능
2. private: 같은 클래스 안에 있는 멤버들만 접근 가능
3. protected: 같은 패키지 안의 모든 클래스와, 다른 패키지의 자식 클래스에서 접근 가능
4. default: 같은 패키지 안의 클래스에서만 접근 가능

public  >  protected  >  default(생략)  >  private 

### 18. 객체지향 설계를 위한 SOLID 원칙과 각각의 특징
- SRP: 단일 책임 원칙
  - 클래스(객체)는 단 하나의 책임(기능담당)만 가져야 한다.
  - 프로그램의 유지보수 성을 높이기 위한 설계
- OCP: 개방 폐쇄 원칙
  - 확장에는 열려있어야 하며, 수정에는 닫혀있어야 한다.
  - 추상화 사용을 통한 관계 구축을 권장 
- LSP: 리스코프 치환 원칙
  - 서브 타입은 언제나 기반(부모)타입으로 교체할 수 있어야 한다.
  - 다형성 원리를 이용하기 위한 원칙 
- ISP: 인터페이스 분리 원칙
  - 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야 한다.
  - 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공 
- DIP: 의존 역전 원칙
  - 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라
  - 인터페이스에 의존해라. 
